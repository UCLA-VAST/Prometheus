#include "output.h"

#define READ_RANGE(Arr, data_size, l)                                          \
  (Arr.data.range((data_size) * (l) + (data_size) - 1, (data_size) * (l)))

/****************************************************
 This file was automatically generated by Prometheus
****************************************************/
void compute_FT1_level0(
    hls::stream<ap_axiu<256, 0, 0, 0>> &fifo_tmp_from_task1_to_task3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_A_from_off_chip_to_S3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_y_to_off_chip, int j0,
    float y_0[16], float y_1[16], float A_0[392][16], float A_1[392][16],
    float tmp[392]) {
#pragma HLS inline off
#pragma HLS dataflow
  read_A_FT1(A_1, fifo_A_from_off_chip_to_S3, j0 + 1);
  task2_intra(y_0, A_0, tmp, j0);
  task3_intra(y_0, A_0, tmp, j0);
  write_y_FT1(y_1, fifo_y_to_off_chip, j0 - 1);
}
void FT1_level0(
    hls::stream<ap_axiu<256, 0, 0, 0>> &fifo_tmp_from_task1_to_task3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_A_from_off_chip_to_S3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_y_to_off_chip) {
#pragma HLS inline off
  float y_0[16];
  // FT1
#pragma HLS array_partition variable = y_0 cyclic factor = 16 dim = 1
  float y_1[16];
  // FT1
#pragma HLS array_partition variable = y_1 cyclic factor = 16 dim = 1
  float A_0[392][16];
  // FT1
#pragma HLS array_partition variable = A_0 cyclic factor = 8 dim = 1
#pragma HLS array_partition variable = A_0 cyclic factor = 16 dim = 2
  float A_1[392][16];
  // FT1
#pragma HLS array_partition variable = A_1 cyclic factor = 8 dim = 1
#pragma HLS array_partition variable = A_1 cyclic factor = 16 dim = 2
  float tmp[392];
#pragma HLS array_partition variable = tmp cyclic factor = 8 dim = 1
  read_tmp_FT1(tmp, fifo_tmp_from_task1_to_task3);
  read_A_FT1(A_0, fifo_A_from_off_chip_to_S3, 0);
  for (int j0 = 0; j0 < 26; j0++) {

    if (j0 % 2 == 0) {
      //     read_A_FT1(A_1, fifo_A_from_off_chip_to_S3, j0+1);
      //     task2_intra(y_0, A_0, tmp, j0);
      //     task3_intra(y_0, A_0, tmp, j0);
      //     write_y_FT1(y_1, fifo_y_to_off_chip, j0-1);
      compute_FT1_level0(fifo_tmp_from_task1_to_task3,
                         fifo_A_from_off_chip_to_S3, fifo_y_to_off_chip, j0,
                         y_0, y_1, A_0, A_1, tmp);
    } else if (j0 % 2 == 1) {
      //     read_A_FT1(A_0, fifo_A_from_off_chip_to_S3, j0+1);
      //     task2_intra(y_1, A_1, tmp, j0);
      //     task3_intra(y_1, A_1, tmp, j0);
      //     write_y_FT1(y_0, fifo_y_to_off_chip, j0-1);
      compute_FT1_level0(fifo_tmp_from_task1_to_task3,
                         fifo_A_from_off_chip_to_S3, fifo_y_to_off_chip, j0,
                         y_1, y_0, A_1, A_0, tmp);
    }
  }
  write_y_FT1(y_1, fifo_y_to_off_chip, 25);
}
void task2_intra(float y[16], float A[392][16], float tmp[392], int j0) {
#pragma HLS inline off
  int j;
  for (int j1 = 0; j1 < 16; j1++) {
#pragma HLS unroll
    j = j0 * 16 + j1;
    y[j1] = 0.0;
  }
}
void task3_intra(float y[16], float A[392][16], float tmp[392], int j0) {
#pragma HLS inline off
  int j;
  int i;
  for (int i0 = 0; i0 < 49; i0++) {
#pragma HLS pipeline II = 2
    for (int j1 = 0; j1 < 16; j1++) {
#pragma HLS unroll
      for (int i1 = 0; i1 < 8; i1++) {
#pragma HLS unroll
        j = j0 * 16 + j1;
        i = i0 * 8 + i1;
        y[j1] = y[j1] + A[i][j1] * tmp[i];
      }
    }
  }
}
void read_tmp_FT1(float tmp[392],
                  hls::stream<float8> &fifo_tmp_from_task1_to_task3) {
#pragma HLS inline off
  for (int d0_0 = 0; d0_0 < 50; d0_0++) {

    for (int d0_1 = 0; d0_1 < 8; d0_1 += 8) {

      int d0 = d0_0 * 8 + d0_1;
      float8 tmp_fifo = fifo_tmp_from_task1_to_task3.read();
      if (d0 + 0 < 392)
        tmp[d0 + 0 + 0] = tmp_fifo[0];
      if (d0 + 1 < 392)
        tmp[d0 + 0 + 1] = tmp_fifo[1];
      if (d0 + 2 < 392)
        tmp[d0 + 0 + 2] = tmp_fifo[2];
      if (d0 + 3 < 392)
        tmp[d0 + 0 + 3] = tmp_fifo[3];
      if (d0 + 4 < 392)
        tmp[d0 + 0 + 4] = tmp_fifo[4];
      if (d0 + 5 < 392)
        tmp[d0 + 0 + 5] = tmp_fifo[5];
      if (d0 + 6 < 392)
        tmp[d0 + 0 + 6] = tmp_fifo[6];
      if (d0 + 7 < 392)
        tmp[d0 + 0 + 7] = tmp_fifo[7];
    }
  }
}
void read_tmp_FT1(
    float tmp[392],
    hls::stream<ap_axiu<256, 0, 0, 0>> &fifo_tmp_from_task1_to_task3) {
#pragma HLS inline off
  for (int d0_0 = 0; d0_0 < 50; d0_0++) {

    for (int d0_1 = 0; d0_1 < 8; d0_1 += 8) {

      int d0 = d0_0 * 8 + d0_1;
      ap_axiu<256, 0, 0, 0> tmp_fifo = fifo_tmp_from_task1_to_task3.read();
      if (d0 + 0 < 392) {
        uint32_t tmp_0 = tmp_fifo.data.range(31, 0);
        tmp[d0 + 0 + 0] = *(float *)(&tmp_0);
      }
      if (d0 + 1 < 392) {
        uint32_t tmp_1 = tmp_fifo.data.range(63, 32);
        tmp[d0 + 0 + 1] = *(float *)(&tmp_1);
      }
      if (d0 + 2 < 392) {
        uint32_t tmp_2 = tmp_fifo.data.range(95, 64);
        tmp[d0 + 0 + 2] = *(float *)(&tmp_2);
      }
      if (d0 + 3 < 392) {
        uint32_t tmp_3 = tmp_fifo.data.range(127, 96);
        tmp[d0 + 0 + 3] = *(float *)(&tmp_3);
      }
      if (d0 + 4 < 392) {
        uint32_t tmp_4 = tmp_fifo.data.range(159, 128);
        tmp[d0 + 0 + 4] = *(float *)(&tmp_4);
      }
      if (d0 + 5 < 392) {
        uint32_t tmp_5 = tmp_fifo.data.range(191, 160);
        tmp[d0 + 0 + 5] = *(float *)(&tmp_5);
      }
      if (d0 + 6 < 392) {
        uint32_t tmp_6 = tmp_fifo.data.range(223, 192);
        tmp[d0 + 0 + 6] = *(float *)(&tmp_6);
      }
      if (d0 + 7 < 392) {
        uint32_t tmp_7 = tmp_fifo.data.range(255, 224);
        tmp[d0 + 0 + 7] = *(float *)(&tmp_7);
      }
    }
  }
}
void read_A_FT1(float A[392][16],
                hls::stream<float16> &fifo_A_from_off_chip_to_S3, int j0) {
#pragma HLS inline off
  if (j0 >= 26) {
    return;
  }
  for (int d0 = 0; d0 < 392; d0++) {
    for (int d1 = 0; d1 < 16; d1 += 16) {
#pragma HLS pipeline II = 1
      float16 tmp_fifo = fifo_A_from_off_chip_to_S3.read();
      A[d0 + 0][d1 + 0 + 0] = tmp_fifo[0];
      A[d0 + 0][d1 + 0 + 1] = tmp_fifo[1];
      A[d0 + 0][d1 + 0 + 2] = tmp_fifo[2];
      A[d0 + 0][d1 + 0 + 3] = tmp_fifo[3];
      A[d0 + 0][d1 + 0 + 4] = tmp_fifo[4];
      A[d0 + 0][d1 + 0 + 5] = tmp_fifo[5];
      A[d0 + 0][d1 + 0 + 6] = tmp_fifo[6];
      A[d0 + 0][d1 + 0 + 7] = tmp_fifo[7];
      A[d0 + 0][d1 + 0 + 8] = tmp_fifo[8];
      A[d0 + 0][d1 + 0 + 9] = tmp_fifo[9];
      A[d0 + 0][d1 + 0 + 10] = tmp_fifo[10];
      A[d0 + 0][d1 + 0 + 11] = tmp_fifo[11];
      A[d0 + 0][d1 + 0 + 12] = tmp_fifo[12];
      A[d0 + 0][d1 + 0 + 13] = tmp_fifo[13];
      A[d0 + 0][d1 + 0 + 14] = tmp_fifo[14];
      A[d0 + 0][d1 + 0 + 15] = tmp_fifo[15];
    }
  }
}
void read_A_FT1(float A[392][16],
                hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_A_from_off_chip_to_S3,
                int j0) {
#pragma HLS inline off
  if (j0 >= 26) {
    return;
  }
  for (int d0 = 0; d0 < 392; d0++) {
    for (int d1 = 0; d1 < 16; d1 += 16) {
#pragma HLS pipeline II = 1
      ap_axiu<512, 0, 0, 0> tmp_fifo = fifo_A_from_off_chip_to_S3.read();
      uint32_t tmp_0 = tmp_fifo.data.range(31, 0);
      A[d0 + 0][d1 + 0 + 0] = *(float *)(&tmp_0);
      uint32_t tmp_1 = tmp_fifo.data.range(63, 32);
      A[d0 + 0][d1 + 0 + 1] = *(float *)(&tmp_1);
      uint32_t tmp_2 = tmp_fifo.data.range(95, 64);
      A[d0 + 0][d1 + 0 + 2] = *(float *)(&tmp_2);
      uint32_t tmp_3 = tmp_fifo.data.range(127, 96);
      A[d0 + 0][d1 + 0 + 3] = *(float *)(&tmp_3);
      uint32_t tmp_4 = tmp_fifo.data.range(159, 128);
      A[d0 + 0][d1 + 0 + 4] = *(float *)(&tmp_4);
      uint32_t tmp_5 = tmp_fifo.data.range(191, 160);
      A[d0 + 0][d1 + 0 + 5] = *(float *)(&tmp_5);
      uint32_t tmp_6 = tmp_fifo.data.range(223, 192);
      A[d0 + 0][d1 + 0 + 6] = *(float *)(&tmp_6);
      uint32_t tmp_7 = tmp_fifo.data.range(255, 224);
      A[d0 + 0][d1 + 0 + 7] = *(float *)(&tmp_7);
      uint32_t tmp_8 = tmp_fifo.data.range(287, 256);
      A[d0 + 0][d1 + 0 + 8] = *(float *)(&tmp_8);
      uint32_t tmp_9 = tmp_fifo.data.range(319, 288);
      A[d0 + 0][d1 + 0 + 9] = *(float *)(&tmp_9);
      uint32_t tmp_10 = tmp_fifo.data.range(351, 320);
      A[d0 + 0][d1 + 0 + 10] = *(float *)(&tmp_10);
      uint32_t tmp_11 = tmp_fifo.data.range(383, 352);
      A[d0 + 0][d1 + 0 + 11] = *(float *)(&tmp_11);
      uint32_t tmp_12 = tmp_fifo.data.range(415, 384);
      A[d0 + 0][d1 + 0 + 12] = *(float *)(&tmp_12);
      uint32_t tmp_13 = tmp_fifo.data.range(447, 416);
      A[d0 + 0][d1 + 0 + 13] = *(float *)(&tmp_13);
      uint32_t tmp_14 = tmp_fifo.data.range(479, 448);
      A[d0 + 0][d1 + 0 + 14] = *(float *)(&tmp_14);
      uint32_t tmp_15 = tmp_fifo.data.range(511, 480);
      A[d0 + 0][d1 + 0 + 15] = *(float *)(&tmp_15);
    }
  }
}
void write_y_FT1(float y[16], hls::stream<float16> &fifo_y_to_off_chip,
                 int j0) {
#pragma HLS inline off
  if (j0 < 0) {
    return;
  }
  for (int d0 = 0; d0 < 16; d0 += 16) {
#pragma HLS pipeline II = 1
    float16 tmp_fifo;
    tmp_fifo[0] = y[d0 + 0 + 0];
    tmp_fifo[1] = y[d0 + 0 + 1];
    tmp_fifo[2] = y[d0 + 0 + 2];
    tmp_fifo[3] = y[d0 + 0 + 3];
    tmp_fifo[4] = y[d0 + 0 + 4];
    tmp_fifo[5] = y[d0 + 0 + 5];
    tmp_fifo[6] = y[d0 + 0 + 6];
    tmp_fifo[7] = y[d0 + 0 + 7];
    tmp_fifo[8] = y[d0 + 0 + 8];
    tmp_fifo[9] = y[d0 + 0 + 9];
    tmp_fifo[10] = y[d0 + 0 + 10];
    tmp_fifo[11] = y[d0 + 0 + 11];
    tmp_fifo[12] = y[d0 + 0 + 12];
    tmp_fifo[13] = y[d0 + 0 + 13];
    tmp_fifo[14] = y[d0 + 0 + 14];
    tmp_fifo[15] = y[d0 + 0 + 15];
    fifo_y_to_off_chip.write(tmp_fifo);
  }
}
void write_y_FT1(float y[16],
                 hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_y_to_off_chip,
                 int j0) {
#pragma HLS inline off
  if (j0 < 0) {
    return;
  }
  for (int d0 = 0; d0 < 16; d0 += 16) {
#pragma HLS pipeline II = 1
    ap_axiu<512, 0, 0, 0> tmp_fifo;
    float tmp_0 = y[d0 + 0 + 0];
    tmp_fifo.data.range(31, 0) = *(uint32_t *)(&tmp_0);
    float tmp_1 = y[d0 + 0 + 1];
    tmp_fifo.data.range(63, 32) = *(uint32_t *)(&tmp_1);
    float tmp_2 = y[d0 + 0 + 2];
    tmp_fifo.data.range(95, 64) = *(uint32_t *)(&tmp_2);
    float tmp_3 = y[d0 + 0 + 3];
    tmp_fifo.data.range(127, 96) = *(uint32_t *)(&tmp_3);
    float tmp_4 = y[d0 + 0 + 4];
    tmp_fifo.data.range(159, 128) = *(uint32_t *)(&tmp_4);
    float tmp_5 = y[d0 + 0 + 5];
    tmp_fifo.data.range(191, 160) = *(uint32_t *)(&tmp_5);
    float tmp_6 = y[d0 + 0 + 6];
    tmp_fifo.data.range(223, 192) = *(uint32_t *)(&tmp_6);
    float tmp_7 = y[d0 + 0 + 7];
    tmp_fifo.data.range(255, 224) = *(uint32_t *)(&tmp_7);
    float tmp_8 = y[d0 + 0 + 8];
    tmp_fifo.data.range(287, 256) = *(uint32_t *)(&tmp_8);
    float tmp_9 = y[d0 + 0 + 9];
    tmp_fifo.data.range(319, 288) = *(uint32_t *)(&tmp_9);
    float tmp_10 = y[d0 + 0 + 10];
    tmp_fifo.data.range(351, 320) = *(uint32_t *)(&tmp_10);
    float tmp_11 = y[d0 + 0 + 11];
    tmp_fifo.data.range(383, 352) = *(uint32_t *)(&tmp_11);
    float tmp_12 = y[d0 + 0 + 12];
    tmp_fifo.data.range(415, 384) = *(uint32_t *)(&tmp_12);
    float tmp_13 = y[d0 + 0 + 13];
    tmp_fifo.data.range(447, 416) = *(uint32_t *)(&tmp_13);
    float tmp_14 = y[d0 + 0 + 14];
    tmp_fifo.data.range(479, 448) = *(uint32_t *)(&tmp_14);
    float tmp_15 = y[d0 + 0 + 15];
    tmp_fifo.data.range(511, 480) = *(uint32_t *)(&tmp_15);
    fifo_y_to_off_chip.write(tmp_fifo);
  }
}

void kernel_nlp_slr1(
    hls::stream<ap_axiu<256, 0, 0, 0>> &fifo_tmp_from_task1_to_task3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_A_from_off_chip_to_S3,
    hls::stream<ap_axiu<512, 0, 0, 0>> &fifo_y_to_off_chip) {
#pragma HLS interface ap_ctrl_none port = return
#pragma HLS inline off
#pragma HLS INTERFACE axis port = fifo_tmp_from_task1_to_task3
#pragma HLS INTERFACE axis port = fifo_A_from_off_chip_to_S3
#pragma HLS INTERFACE axis port = fifo_y_to_off_chip
  FT1_level0(fifo_tmp_from_task1_to_task3, fifo_A_from_off_chip_to_S3,
             fifo_y_to_off_chip);
}
